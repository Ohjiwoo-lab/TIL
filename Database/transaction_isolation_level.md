# Transaction Isolation Level

이는 여러 개의 트랜잭션이 동시에 수행될 때 서로 독립적으로 수행되어야 함을 보장하기 위해 사용됩니다. 격리 수준은 총 4가지로 나눠져 있습니다.

1. Read Incommitted

가장 낮은 수준의 레벨로, 각 트랜잭션에서의 변경 내용이 반영되었는지(commit) 여부에 상관없이 다른 트랜잭션에서 값을 읽을 수 있다. 아직 트랜잭션 작업이 완료되지 않았음에도 다른 트랜잭션에서 변경 내용을 확인할 수 있으므로 `Dirty Read` 현상이 발생한다.

2. Read Committed

Commit이 완료된 트랜잭션에 대해서만 값을 읽어오는 방식이다. 하지만 Commit이 이루어지기 전에 데이터를 읽고 트랜잭션을 유지한 상태에서 Commit이 이루어지고 난 후 데이터를 다시 읽게 되면 서로 다른 결과를 가져온다는 문제점 `Non-Repeatable Read`이 있다. 원래 하나의 트랜잭션에서 동일한 쿼리를 수행했다면, 동일한 결과가 나와야 하는데 그렇지 않은 것이다. 하지만 Commit이 완료된 데이터만 가져오기 때문에 `Dirty Read` 현상은 발생하지 않는다.

이는 대부분의 RDBMS에서 사용하는 방식이다.

3. Repeatable Read

트랜잭션마다 ID를 부여해서 트랜잭션이 시작되기 전에 변경된 사항만 읽어오는 방식이다. 그래서 트랜잭션이 진행 중일 때 변경된 사항은 반영되지 않아 정확성을 보장해주지는 않는다.

데이터 변경에 대해서는 일관성을 유지해주기 때문에 `Dirty Read`나 `Non-Repeatable Read`는 발생하지 않지만, 데이터를 삽입할 때 문제가 발생한다. 트랜잭션이 진행 중일 때 데이터의 삽입이 일어난다면 없던 데이터가 갑자기 추가되는 `Phantom Read`가 발생한다.

이는 MySQL에서 사용되는 방식이며, Lock을 이용하여 Phantom Read가 일어나지 않도록 하는 방식도 있다고 한다. (이는 차차 알아보자)

4. Serializable

가장 높은 수준의 레벨이다. 이는 한 번에 하나의 트랜잭션만 수행하도록 하는 방식이며, 트랜잭션 간의 완전한 독립성을 유지해줄 수 있다. Dirty Read, Non-Repeatable Read, Phantom Read가 모두 발생하지는 않지만, 데이터의 쿼리를 처리하는 속도가 너무 저하되어 데이터베이스에서는 거의 사용되지 않는 방식이다.

📌 2024-1-8: 트랜잭션 격리 수준 정리 - 나중에 더 공부해서 추가하자.